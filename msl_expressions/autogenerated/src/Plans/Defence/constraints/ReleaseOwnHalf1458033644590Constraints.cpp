#include "Plans/Defence/constraints/ReleaseOwnHalf1458033644590Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1458033644590) ENABLED START*/
// Add additional using directives here
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "MSLFootballField.h"
#include "MSLWorldModel.h"
#include "engine/Assignment.h"
#include "engine/RunningPlan.h"
#include "engine/constraintmodul/ProblemDescriptor.h"
#include "engine/model/AbstractPlan.h"
#include "engine/model/EntryPoint.h"
#include "engine/model/Plan.h"
#include "engine/model/Task.h"
#include <Ball.h>
#include <RawSensorData.h>
#include <Robots.h>
#include <WhiteBoard.h>
#include <container/CNPosition.h>

#include <msl/robot/IntRobotID.h>
#include <supplementary/IAgentID.h>
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
// Plan:ReleaseOwnHalf

/*
 * Tasks:
 * - EP:1458033660893 : DefaultTask (1225112227903)
 *
 * States:
 * - ReleaseOwnHalf (1458033660892)
 *
 * Vars:
 * - X (1458033962376)
 * - Y (1458033968280)
 */

/*
 * RuntimeCondition - (Name): NewRuntimeCondition
 * (ConditionString):
 * Static Variables: [X, Y]
 * Domain Variables:

 */
void Constraint1458033759784::getConstraint(shared_ptr<ProblemDescriptor> c, shared_ptr<RunningPlan> rp)
{
    /*PROTECTED REGION ID(cc1458033759784) ENABLED START*/
    msl::MSLWorldModel *wm = msl::MSLWorldModel::get();
    auto util = autodiff::TermBuilder::constant(0);
    auto constraint = autodiff::LTConstraint::TRUE;
    c->getStaticRanges()->at(0).at(0) = -wm->field->getFieldLength() / 2.0 + wm->field->getPenaltyAreaLength();
    c->getStaticRanges()->at(0).at(1) = wm->field->getFieldLength() / 2.0 - wm->field->getPenaltyAreaWidth();
    c->getStaticRanges()->at(1).at(0) = -wm->field->getFieldWidth() / 2.0;
    c->getStaticRanges()->at(1).at(1) = wm->field->getFieldWidth() / 2.0;

    vector<shared_ptr<autodiff::Term>> targetPosVec;
    targetPosVec.push_back(dynamic_pointer_cast<autodiff::Term>(c->getStaticVars()->at(0)));
    targetPosVec.push_back(dynamic_pointer_cast<autodiff::Term>(c->getStaticVars()->at(1)));
    shared_ptr<autodiff::TVec> tMidFieldDefPos = make_shared<autodiff::TVec>(targetPosVec);

    // Get the Attacker Pos
    EntryPoint *attackerEp = nullptr;
    shared_ptr<RunningPlan> cur = rp->getParent().lock();
    while (cur != nullptr)
    {
        if (cur->getPlan()->getName().compare("AttackPlay"))
        {
            for (auto e : ((Plan *)cur->getPlan())->getEntryPoints())
            {
                if (e.second->getTask()->getName().compare("Attack"))
                {
                    attackerEp = e.second;
                    break;
                }
            }
            break;
        }
        cur = cur->getParent().lock();
    }

    if (attackerEp == nullptr)
    {
        cout << "ReleaseOwnHalfConstraints: No Attacker EntryPoint found!" << endl;
        constraint = constraint & ConstraintBuilder::FALSE;
        return;
    }

    cur = rp->getParent().lock();
    shared_ptr<vector<const supplementary::IAgentID *>> attacker = nullptr;
    while (cur != nullptr)
    {
        if (((Plan *)cur->getPlan())->getEntryPoints().find(attackerEp->getId()) != ((Plan *)cur->getPlan())->getEntryPoints().end())
        {
            attacker = cur->getAssignment()->getRobotsWorking(attackerEp);
            break;
        }
        cur = cur->getParent().lock();
    }

    shared_ptr<geometry::CNPosition> attackerPos = nullptr;
    if (attacker != nullptr)
    {
        for (auto mateId : *attacker)
        {
            attackerPos = wm->robots->teammates.getTeamMatePosition(dynamic_cast<const msl::robot::IntRobotID *>(mateId));
            break;
        }
    }

    if (attackerPos == nullptr)
    {
        cout << "ReleaseOwnHalfConstraints: No Attacker Position found!" << endl;
        constraint = constraint & ConstraintBuilder::FALSE;
        return;
    }

    shared_ptr<autodiff::TVec> tAttackerPos = make_shared<autodiff::TVec>(initializer_list<double>{attackerPos->x, attackerPos->y});
    constraint = constraint & ConstraintBuilder::distanceSqr(tAttackerPos, tMidFieldDefPos) > autodiff::TermBuilder::constant(2000.0 * 2000.0);
    constraint = constraint & autodiff::TermBuilder::constant(make_shared<autodiff::Abs>(tMidFieldDefPos->getY() - tAttackerPos->getY()) >
                                                              autodiff::TermBuilder::constant(500.0));

    // min dist away from all obtacles
    auto opps = wm->robots->opponents.getOpponentsAlloClustered(); // GetTrackedOpponents();
    if (opps->size() > 0)
    {
        for (int i = 0; i < opps->size(); i++)
        {
            shared_ptr<autodiff::TVec> tOpp = make_shared<autodiff::TVec>(initializer_list<double>{opps->at(i)->x, opps->at(i)->y});
            constraint = constraint & ConstraintBuilder::distanceSqr(tOpp, tMidFieldDefPos) > autodiff::TermBuilder::constant(700.0 * 700.0);
        }
    }

    auto teammates = wm->robots->teammates.getTeammatesAlloClustered();
    if (teammates->size() > 0)
    {
        for (int i = 0; i < teammates->size(); i++)
        {
            shared_ptr<autodiff::TVec> tMate = make_shared<autodiff::TVec>(initializer_list<double>{teammates->at(i)->x, teammates->at(i)->y});
            constraint = constraint & ConstraintBuilder::distanceSqr(tMate, tMidFieldDefPos) > autodiff::TermBuilder::constant(1500.0 * 1500.0);
        }
    }

    shared_ptr<autodiff::TVec> optP1 = tAttackerPos + make_shared<autodiff::TVec>(initializer_list<double>{-400.0, 2000.0});
    shared_ptr<autodiff::TVec> optP2 = tAttackerPos + make_shared<autodiff::TVec>(initializer_list<double>{-400.0, -2000.0});

    shared_ptr<autodiff::Term> weightShiftP1 = (1 - make_shared<autodiff::Abs>(optP1->getY()) / (wm->field->getFieldWidth() / 2));
    shared_ptr<autodiff::Term> weightShiftP2 = (1 - make_shared<autodiff::Abs>(optP2->getY()) / (wm->field->getFieldWidth() / 2));

    shared_ptr<geometry::CNPosition> pos = wm->rawSensorData->getOwnPositionVision();
    if (pos != nullptr)
    {
        shared_ptr<geometry::CNPoint2D> distVec1 = (attackerPos->getPoint() + make_shared<geometry::CNPoint2D>(-400.0, 2000)) - pos;
        shared_ptr<geometry::CNPoint2D> distVec2 = (attackerPos->getPoint() + make_shared<geometry::CNPoint2D>(-400.0, -2000)) - pos;
        if (distVec1->length() > distVec2->length())
        {
            if (attackerPos->y < -500 || (distVec1->length() < 1800.0 && attackerPos->y < 500))
            {
                util = util + 5 * (1 - ConstraintBuilder::distanceSqr(optP1, tMidFieldDefPos) / wm->field->getMaxDistanceSqr()) * weightShiftP1;
            }
            else
            {
                util = util + 5 * (1 - ConstraintBuilder::distanceSqr(optP2, tMidFieldDefPos) / wm->field->getMaxDistanceSqr()) * weightShiftP2;
            }
        }
        else
        {
            if (attackerPos->y > 500 || (distVec2->length() < 1800.0 && attackerPos->y > -500))
            {
                util = util + 5 * (1 - ConstraintBuilder::distanceSqr(optP2, tMidFieldDefPos) / wm->field->getMaxDistanceSqr()) * weightShiftP2;
            }
            else
            {
                util = util + 5 * (1 - ConstraintBuilder::distanceSqr(optP1, tMidFieldDefPos) / wm->field->getMaxDistanceSqr()) * weightShiftP1;
            }
        }

        // avoid teammates
        auto mates = wm->robots->teammates.getTeammatesAlloClustered();
        vector<shared_ptr<autodiff::TVec>> mateVec;
        if (mates != nullptr)
        {
            for (int i = 0; i < mates->size(); i++)
            {
                mateVec.push_back(make_shared<autodiff::TVec>(initializer_list<double>{mates->at(i)->x, mates->at(i)->y}));
                constraint = constraint &
                             ConstraintBuilder::distanceSqr(tMidFieldDefPos, mateVec[i]) > autodiff::TermBuilder::constant(750 * 750); // get away from mates
            }
        }
        // Pass should be at most 2m away from the ball (relevant if we do not have the ball)
        shared_ptr<geometry::CNPoint2D> ballPos = wm->ball->getAlloBallPosition();
        if (ballPos != nullptr && (wm->whiteBoard->getPassMsg() == nullptr ||
                                   !equal(wm->whiteBoard->getPassMsg()->receiverID.id.begin(), wm->whiteBoard->getPassMsg()->receiverID.id.end(),
                                          wm->getOwnId()->toByteVector().begin())))
        {
            shared_ptr<TVec> tvecBallPose = make_shared<TVec>(initializer_list<double>{ballPos->x, ballPos->y});
            constraint = constraint & (ConstraintBuilder::distanceSqr(tMidFieldDefPos, tvecBallPose) > autodiff::TermBuilder::constant(1500 * 1500));
        }

        // add 'lazyness' utility for stability:
        shared_ptr<autodiff::Term> util2 =
            1 -
            ConstraintBuilder::distanceSqr(tMidFieldDefPos, make_shared<autodiff::TVec>(initializer_list<double>{pos->x, pos->y})) /
                wm->field->getMaxDistanceSqr();
        util = util + util2 * util2;
        c->setConstraint(dynamic_pointer_cast<alica::SolverTerm>(constraint));
        c->setUtility(dynamic_pointer_cast<alica::SolverTerm>(util));
    }

    /*PROTECTED REGION END*/
}

// State: ReleaseOwnHalf

// State: ReleaseOwnHalf
}
